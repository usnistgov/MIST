// Disclaimer: IMPORTANT: This software was developed at the National
// Institute of Standards and Technology by employees of the Federal
// Government in the course of their official duties. Pursuant to
// title 17 Section 105 of the United States Code this software is not
// subject to copyright protection and is in the public domain. This
// is an experimental system. NIST assumes no responsibility
// whatsoever for its use by other parties, and makes no guarantees,
// expressed or implied, about its quality, reliability, or any other
// characteristic. We would appreciate acknowledgement if the software
// is used. This software can be redistributed and/or modified freely
// provided that any derivative works bear some notice that they are
// derived from it, and any modified versions bear some notice that
// they have been modified.


// ================================================================
//
// Author: tjb3
// Date: Aug 1, 2013 4:06:31 PM EST
//
// Time-stamp: <Aug 1, 2013 4:06:31 PM tjb3>
//
//
// ================================================================

package gov.nist.isg.mist.lib32.imagetile.utilfns;

import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Pointer;
import org.bridj.ann.Library;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;

/**
 * Wrapper for library <b>util-fns</b><br> This file was autogenerated by <a
 * href="http://jnaerator.googlecode.com/">JNAerator</a>,<br> a tool written by <a
 * href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses
 * a few opensource projects.</a>.<br> For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a>
 * or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("utilfns")
@Runtime(CRuntime.class)
public class UtilFnsLibrary32 {
  static {
    BridJ.register();
  }

  /**
   * normalize resulting vector to have magnitude <= 1<br> Original signature : <code>void
   * elt_prod_conj_norm(float*, float*, float*, int)</code><br> <i>native declaration :
   * util-fns.h:1207</i>
   *
   * @param res the res
   * @param c1  the c1
   * @param c2  the c2
   * @param sz  the sz
   */
  public static void elt_prod_conj_norm(Pointer<Float> res, Pointer<Float> c1, Pointer<Float> c2, int sz) {
    elt_prod_conj_norm(Pointer.getPeer(res), Pointer.getPeer(c1), Pointer.getPeer(c2), sz);
  }

  /**
   * Elt_prod_conj_norm.
   *
   * @param res the res
   * @param c1  the c1
   * @param c2  the c2
   * @param sz  the sz
   */
  protected native static void elt_prod_conj_norm(@Ptr long res, @Ptr long c1, @Ptr long c2, int sz);

  /**
   * Original signature : <code>int reduce_max_abs(double*, int)</code><br> <i>native declaration :
   * util-fns.h:1209</i>
   *
   * @param floatPtr1 the double ptr1
   * @param int1      the int1
   * @return the int
   */
  public static int reduce_max_abs(Pointer<Float> floatPtr1, int int1) {
    return reduce_max_abs(Pointer.getPeer(floatPtr1), int1);
  }

  /**
   * Reduce_max_abs.
   *
   * @param floatPtr1 the double ptr1
   * @param int1      the int1
   * @return the int
   */
  protected native static int reduce_max_abs(@Ptr long floatPtr1, int int1);

  /**
   * Original signature : <code>int* get_multi_max(double*, int, int, int, double, int*)</code><br>
   * <i>native declaration : util-fns.h:1211</i>
   *
   * @param v        the v
   * @param nComplex the n complex
   * @param w        the w
   * @param h        the h
   * @param min_dist the min_dist
   * @param peaks    the peaks
   */
  public static void get_multi_max(Pointer<Float> v, int nComplex, int w, int h, double min_dist,
                                   Pointer<Integer> peaks) {
    get_multi_max(Pointer.getPeer(v), nComplex, w, h, min_dist, Pointer.getPeer(peaks));
  }

  /**
   * Gets the _multi_max.
   *
   * @param v        the v
   * @param nComplex the n complex
   * @param w        the w
   * @param h        the h
   * @param min_dist the min_dist
   * @param peaks    the peaks
   */
  protected native static void get_multi_max(@Ptr long v, int nComplex, int w, int h,
                                             double min_dist, @Ptr long peaks);

  /**
   * Gets the _multi_max_no_sort.
   *
   * @param v        the v
   * @param nPeaks   the n peaks
   * @param w        the w
   * @param h        the h
   * @param min_dist the min_dist
   * @param peaks    the peaks
   */
  public static void get_multi_max_no_sort(Pointer<Float> v, int nPeaks, int w, int h,
                                           double min_dist, Pointer<Integer> peaks) {
    get_multi_max_no_sort(Pointer.getPeer(v), nPeaks, w, h, min_dist, Pointer.getPeer(peaks));
  }

  /**
   * Original signature : <code>int* get_multi_max_no_sort(double*, int, int, int, double,
   * int*)</code> <br> <i>native declaration : util-fns.h:1211</i>
   *
   * @param v        the v
   * @param nPeaks   the n peaks
   * @param w        the w
   * @param h        the h
   * @param min_dist the min_dist
   * @param peaks    the peaks
   */
  protected native static void get_multi_max_no_sort(@Ptr long v, int nPeaks, int w, int h,
                                                     double min_dist, @Ptr long peaks);

}
